# APIエンドポイントの基本的な設計

WebAPIのエンドポイント(接続先ロケーション)は URI になります。
通常のウェブサイト・ウェブサービスと同様に、APIに設定するURIにも良い設計をする必要があります。

本記事では、APIの良いURI設計について、[O'Reilly Japan - Web API: The Good Parts](https://www.oreilly.co.jp/books/9784873116860/)から抜粋してまとめます。

## エンドポイントの基本的な設計

良い URI の設計において、非常に重要な原則は以下のようなものです。

**覚えやすく、どんな機能を持つ URI なのかがひと目でわかる**

人間の目から見てわかりやすい URI にすることで、開発者の間違いを防止し、生産性を向上させます。
わかりやすい URI の定義をもう少し具体的に整理したものが以下になります。

- 短く入力しやすい URI
- 人間が読んで理解できる URI
- 大文字小文字が混在していない URI
- 改造しやすい（Hackable な） URI
- サーバ側のアーキテクチャが反映されていない URI
- ルールが統一された URI

それぞれの意味について、簡単に整理します。

### 短く入力しやすい URI
短く入力しやすいということは、シンプルで覚えやすいことに繋がります。
長い URI には不要な情報が入っていたり、意味が重複したりする場合があります。

▼ 悪い例
  `http://api.example.com/service/api/search` 

  - 「api」「search」という言葉から、検索用のAPIであることがわかる
  - 「api」という言葉が重複している
  - 「service」という言葉も、類似した概念となり無駄な表現

▼ 良い例
  `http://api.example.com/search`

  - この URI でも検索用のAPIであることがわかる
  - 理解しやすく、覚えやすい。入力間違いも少なくなる

### 人間が読んで理解できる URI
上記の検索 API の URI のように、その URI を見れば、それ以外の情報がなくてもそれが何を目的としたものなのかがある程度わかることを意味します。

▼ 悪い例
  `http://api.example.com/sv/u/`
  
  - API であることはわかる
  - 「sv」「u」の意味がわからない
    - server, user の略かもしれないが、確信を持てない

＜ ポイント ＞
① 無闇に省略形を使わない
  - products = prod , week = wk などは使用しない
  - 「jp」など、標準化されたコードとして体系化されたものはOK

② API でよく使われる英単語を使用する
  - 英語を使用する
    - `http://api.example.com/products/123`  // 英語
    - `http://api.example.com/productos/123` // スペイン語
    - `http://api.example.com/seihin/123`    // 日本語
    - 英語が万人に伝わりやすいことがわかる
  - 一般的に API で良く使われる語彙を使う
    - 検索用の API の場合、良く使われるのは「search」であり「find」ではない
  - スペルミスをしないこと
    - HTTPリクエストの「Referer」はスペルミスを使い続けている（通常の英単語は「Referrer」）
    - 登録する処理を意味する「regist」は正しくは「register」

### 大文字小文字が混在していない URI
URI の中にアルファベットの大文字と小文字を混在させず、基本はすべて小文字を使う。

▼ 悪い例
  `http://api.example.com/Users/123`
  `http://example.com/API/getUserName`

▼ 良い例
  `http://api.example.com/users/123`

＜ ポイント ＞
  - ホスト名は通常小文字で表示されるため、続くパスも小文字で統一するとよい
  - getUserName のような場合
    - `get_user_name`,`get-user-name`にすれば良いわけではない
    - そもそも`getUserName`のような名付けに問題がある

### 改造しやすい（Hackable な） URI
Hackable とは、URI を修正して別の URI にするのが容易であることを意味します。

▼ 良い例
  `http://api.example.com/v1/items/12436`

  - アイテムの ID が 12436 であるということが推測できる
  - この番号を変更すると、別のアイテムの情報にもアクセス可能であることが予測できる

＜ ポイント ＞
  - ドキュメントを確認するストレスが軽減する
  
▼ 悪い例

  | ID の範囲   | エンドポイント                            |
  | ----------- | ----------------------------------------- |
  | 1 ~ 3000    | http://api.example.com/v1/items/alpha/:id |
  | 3001 ~ 5000 | http://api.example.com/v1/items/beta/:id  |
  | 5001 ~ 7000 | http://api.example.com/v1/items/gamma/:id |
  | 7001 ~      | http://api.example.com/v1/items/delta/:id |

  もし、データベースのテーブルの都合上、このような仕様になった場合、いちいちIDを見ながら場合分けをしなければならず、分割も不規則のため将来の予測を立てることもできません。
  こうしたサーバ側の都合はサーバ内で処理をし、利用者にそれを意識させないのが美しい設計です。

### サーバ側のアーキテクチャが反映されていない URI
サーバ側のアーキテクチャとは、例えばどんなソフトウェアを利用しているか、どんな言語で実装しているか、サーバサイドのディレクトリやシステム構成がどうなっているかということです。

▼ 悪い例
  `http://api.example.com/cgi-bin/get_user.php?user=100`

  - この API はおそらく PHP で書かれていて CGI として動作していることがわかってしまう
  - セキュリティ上の脆弱性となりうる

＜ ポイント ＞
- サーバ側のアーキテクチャは API 利用者にとって不要な情報
- ウェブアプリケーションにおいても同様に URI がサーバ側のアーキテクチャを反映する必要はない
- URI が反映すべきは機能やデータの構造と意味

### ルールが統一された URI
ルールとは、利用する単語、URI の構造などを意味します。

▼ 悪い例
  ●友達の情報の取得
  `http://api.example.com/friends?id=100`
  
  ●メッセージの投稿
  `http://api.example.com/friend/100/message`

  - 取得の API
    - `friends`と複数形が使われている
    - ID はクエリパラメータで指定
  - 投稿の API
    - `friend`,`message`と単数形が使われている
    - ID はパスで指定

  ルールがバラバラの場合、混乱を招きやすいです。

▼ 良い例
  ●友達の情報の取得
  `http://api.example.com/friends/100`
  
  ●メッセージの投稿
  `http://api.example.com/friends/100/message`

  ルールが統一され、理解が容易で利用しやすいです。